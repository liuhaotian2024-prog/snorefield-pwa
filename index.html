<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>SnoreField v7.7 — Fixed Toolbar (Activate + SelfTest)</title>
  <style>
    :root{
      --bg:#050505; --txt:#eee; --accent:#0a84ff;
      --snore:#00f2ff; --target:#ff9f0a; --intv:#ff3b30;
      --ok:#31c48d; --warn:#f6ad55; --bad:#fc8181;
    }
    html,body{height:100%; margin:0; font-family: ui-monospace, Menlo, Monaco, Consolas, monospace; background:var(--bg); color:var(--txt); overflow:hidden;}
    .wrap{height:100%; display:flex; flex-direction:column;}
    .scope{height:260px; background:#000; border-bottom:1px solid #333; position:relative;}
    canvas{width:100%; height:100%; display:block;}
    .legend{position:absolute; top:10px; left:10px; font-size:10px; display:flex; gap:14px; pointer-events:none; opacity:.9;}
    .dot{width:8px;height:8px;border-radius:50%;display:inline-block;margin-right:4px;}
    .math{position:absolute; top:30px; left:10px; font-size:10px; color:#9a9a9a; line-height:1.55; pointer-events:none;}
    .hi{color:var(--accent); font-weight:900;}
    .top-right{position:absolute; top:10px; right:10px; display:flex; flex-direction:column; gap:6px; align-items:flex-end;}
    .pill{padding:4px 9px; border:1px solid #333; border-radius:999px; font-size:10px; color:#bbb; background:rgba(0,0,0,.35);}
    .pill.ok{border-color:rgba(49,196,141,.6); color:rgba(49,196,141,.95);}
    .pill.warn{border-color:rgba(246,173,85,.6); color:rgba(246,173,85,.95);}
    .pill.bad{border-color:rgba(252,129,129,.6); color:rgba(252,129,129,.95);}

    .content{flex:1; overflow:auto; padding:14px 14px 110px;}
    .title{font-size:18px; font-weight:900; text-align:center; letter-spacing:1px;}
    .sub{font-size:12px; color:#777; text-align:center; margin-top:6px;}

    .panel{margin-top:14px; border:1px solid #333; border-radius:12px; padding:12px; background:#0a0a0a;}
    .row{display:flex; gap:10px; flex-wrap:wrap;}
    .col{flex:1; min-width:150px; display:flex; flex-direction:column; gap:6px;}
    .label{font-size:11px; color:#888; display:flex; justify-content:space-between;}
    select,input[type=range]{width:100%; background:#0c0c0c; border:1px solid #333; border-radius:10px; padding:10px; color:#ddd; outline:none;}
    input[type=range]{padding:0; height:36px;}
    .toggle{display:flex; gap:8px; align-items:center; color:#aaa; font-size:11px;}
    .toggle input{transform:scale(1.1);}
    .btn{background:#0b0b0b; border:1px solid #444; color:#ddd; padding:12px; border-radius:10px; font-weight:900; font-size:12px;}
    .btn.blue{border-color:#59f; color:#def;}
    .btn.amber{border-color:#fa3; color:#ffe;}
    .btn.green{border-color:#2b5; color:#cfe;}
    .btn-test{background:#111; border:1px solid #333; color:#bbb; padding:12px; border-radius:10px; font-weight:900; font-size:12px; touch-action:none;}
    .btn-test.active{background:var(--snore); color:#000;}

    details{margin-top:12px; border:1px solid #333; border-radius:12px; padding:10px; background:#060606;}
    summary{cursor:pointer; color:#888; font-size:11px; font-weight:900;}
    pre{white-space:pre-wrap; font-size:10px; color:#9aa; margin:8px 0 0;}

    .toolbar{
      position:fixed; left:0; right:0; bottom:0;
      background:rgba(0,0,0,.85); border-top:1px solid #222;
      padding:10px 12px; display:flex; gap:10px; justify-content:space-between; align-items:center;
      backdrop-filter: blur(10px);
    }
    .toolbtn{
      flex:1;
      background:#111; border:1px solid #333; color:#eee;
      padding:12px; border-radius:12px; font-weight:900; font-size:12px;
    }
    .toolbtn.primary{border-color:rgba(10,132,255,.7); background:rgba(10,132,255,.18);}
    .toolbtn.warn{border-color:rgba(246,173,85,.7); background:rgba(246,173,85,.12);}
    .toolbtn.ok{border-color:rgba(49,196,141,.7); background:rgba(49,196,141,.12);}
  </style>
</head>
<body>
<div class="wrap">

  <div class="scope">
    <div class="legend">
      <div><span class="dot" style="background:var(--snore)"></span>Y</div>
      <div><span class="dot" style="background:var(--target)"></span>Y*</div>
      <div><span class="dot" style="background:var(--intv)"></span>u</div>
    </div>

    <div class="math">
      Phase: <span class="hi" id="mPhase">IDLE</span> | Stage: <span class="hi" id="mStage">CALM</span><br>
      Nudge: <span class="hi" id="mNudge">--</span> | Motion: <span class="hi" id="mMotion">OFF</span><br>
      CIEU: <span class="hi" id="mCieu">0</span> | IF ΔE: <span class="hi" id="mDE">--</span>
    </div>

    <div class="top-right">
      <div class="pill warn" id="pillAudio">audio: suspended</div>
      <div class="pill warn" id="pillMic">mic: off</div>
      <div class="pill warn" id="pillMotion">motion: off</div>
    </div>

    <canvas id="scopeCanvas"></canvas>
  </div>

  <div class="content">
    <div class="title">SnoreField</div>
    <div class="sub">v7.7 — Bottom toolbar always visible (Activate / Self Test)</div>

    <div class="panel">
      <div class="row">
        <div class="col">
          <div class="label"><span>MODE</span><span id="vMode">AUTO</span></div>
          <select id="modeSel">
            <option value="auto">AUTO</option>
            <option value="monitor">MONITOR (S0)</option>
            <option value="gentle">GENTLE</option>
            <option value="standard">STANDARD</option>
          </select>
        </div>
        <div class="col">
          <div class="label"><span>SLEEP</span><span id="vSleep">AUTO</span></div>
          <select id="sleepSel">
            <option value="AUTO">AUTO</option>
            <option value="OCEAN_SOFT">OCEAN_SOFT</option>
            <option value="OCEAN_PAD">OCEAN_PAD</option>
            <option value="RAIN_SOFT">RAIN_SOFT</option>
            <option value="PINK_SOFT">PINK_SOFT</option>
            <option value="OFF">OFF</option>
          </select>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="col">
          <div class="label"><span>CAP</span><span id="vCap">0.10</span></div>
          <input type="range" id="cap" min="0" max="0.20" step="0.005" value="0.10">
        </div>
        <div class="col">
          <div class="label"><span>SLEEP VOL</span><span id="vSleepVol">0.70</span></div>
          <input type="range" id="sleepVol" min="0" max="1" step="0.02" value="0.70">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="col">
          <div class="label"><span>THR</span><span id="vThr">120</span></div>
          <input type="range" id="thr" min="45" max="210" step="1" value="120">
        </div>
        <div class="col">
          <div class="label"><span>OPTION (sec)</span><span id="vOpt">15</span></div>
          <input type="range" id="opt" min="10" max="30" step="1" value="15">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="col">
          <div class="label"><span>α</span><span id="vAlpha">0.65</span></div>
          <input type="range" id="alpha" min="0.05" max="2.5" step="0.05" value="0.65">
        </div>
        <div class="col">
          <div class="label"><span>SQ WEIGHT</span><span id="vSqw">1.4</span></div>
          <input type="range" id="sqw" min="0.7" max="2.5" step="0.1" value="1.4">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <label class="toggle"><input type="checkbox" id="useMotion"> Use DeviceMotion</label>
        <button class="btn gray" id="btnMotionPerm" type="button">REQUEST MOTION PERMISSION</button>
        <label class="toggle"><input type="checkbox" id="ifProbe"> IF Probe L1</label>
        <label class="toggle"><input type="checkbox" id="autoBackup" checked> Auto Backup</label>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn green" id="btnExportReport" type="button">EXPORT REPORT</button>
        <button class="btn blue" id="btnExportLocal" type="button">EXPORT LOCAL DB</button>
        <button class="btn amber" id="btnSnapshot" type="button">SAVE SNAPSHOT</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn-test" id="btnSim">HOLD TO SIMULATE SNORE (FORCE EVENT)</button>
      </div>

      <details>
        <summary>Debug / Errors</summary>
        <pre id="debug"></pre>
      </details>
    </div>
  </div>

  <div class="toolbar">
    <button class="toolbtn primary" id="btnActivate">ACTIVATE</button>
    <button class="toolbtn warn" id="btnSelfTest">SELF TEST</button>
    <button class="toolbtn ok" id="btnExportQuick">EXPORT</button>
  </div>

</div>

<script>
/* ========= error trap ========= */
const D=(msg)=>{ const el=document.getElementById("debug"); el.textContent = String(msg)+"\n\n"+el.textContent; };
window.addEventListener("error",(e)=>D(`[JS ERROR] ${e.message} @ ${e.filename}:${e.lineno}:${e.colno}`));

/* ========= ui ========= */
const $=(id)=>document.getElementById(id);
const ui={
  modeSel:$("modeSel"), sleepSel:$("sleepSel"),
  cap:$("cap"), sleepVol:$("sleepVol"), thr:$("thr"), opt:$("opt"), alpha:$("alpha"), sqw:$("sqw"),
  vMode:$("vMode"), vSleep:$("vSleep"), vCap:$("vCap"), vSleepVol:$("vSleepVol"), vThr:$("vThr"), vOpt:$("vOpt"), vAlpha:$("vAlpha"), vSqw:$("vSqw"),
  useMotion:$("useMotion"), btnMotionPerm:$("btnMotionPerm"),
  ifProbe:$("ifProbe"), autoBackup:$("autoBackup"),
  btnExportReport:$("btnExportReport"), btnExportLocal:$("btnExportLocal"), btnSnapshot:$("btnSnapshot"),
  btnSim:$("btnSim"),
  pillAudio:$("pillAudio"), pillMic:$("pillMic"), pillMotion:$("pillMotion"),
  mPhase:$("mPhase"), mStage:$("mStage"), mNudge:$("mNudge"), mMotion:$("mMotion"), mCieu:$("mCieu"), mDE:$("mDE"),
  cvs:$("scopeCanvas"),
  btnActivate:$("btnActivate"),
  btnSelfTest:$("btnSelfTest"),
  btnExportQuick:$("btnExportQuick"),
};

const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const nowMs=()=>performance.now();
const wallNow=()=>Date.now();
const fmt=(x,d=3)=> (typeof x==="number"? x.toFixed(d): String(x));

function setPill(el, kind, text){
  el.classList.remove("ok","warn","bad");
  el.classList.add(kind);
  el.textContent=text;
}

function syncUI(){
  ui.vMode.textContent=ui.modeSel.value.toUpperCase();
  ui.vSleep.textContent=ui.sleepSel.value;
  ui.vCap.textContent=(+ui.cap.value).toFixed(2);
  ui.vSleepVol.textContent=(+ui.sleepVol.value).toFixed(2);
  ui.vThr.textContent=ui.thr.value;
  ui.vOpt.textContent=ui.opt.value;
  ui.vAlpha.textContent=(+ui.alpha.value).toFixed(2);
  ui.vSqw.textContent=(+ui.sqw.value).toFixed(1);
}
["input","change"].forEach(ev=>{
  ui.modeSel.addEventListener(ev,syncUI);
  ui.sleepSel.addEventListener(ev,syncUI);
  ui.cap.addEventListener(ev,syncUI);
  ui.sleepVol.addEventListener(ev,syncUI);
  ui.thr.addEventListener(ev,syncUI);
  ui.opt.addEventListener(ev,syncUI);
  ui.alpha.addEventListener(ev,syncUI);
  ui.sqw.addEventListener(ev,syncUI);
});
syncUI();

function getTHR(){return parseInt(ui.thr.value,10);}
function getCap(){return parseFloat(ui.cap.value);}
function getSleepVol(){return parseFloat(ui.sleepVol.value);}
function getOptSec(){return parseFloat(ui.opt.value);}
function getAlpha(){return parseFloat(ui.alpha.value);}
function getSQW(){return parseFloat(ui.sqw.value);}

let running=false;
let stage="CALM", phase="IDLE";
function getMode(){
  const v=ui.modeSel.value;
  if(v!=="auto") return v;
  if(phase==="ONSET"||phase==="AROUSAL") return "gentle";
  if(stage==="CALM") return "gentle";
  return "standard";
}

/* ========= storage ========= */
const STORE={DB:"snorefield_v7_7_db"};
function loadJSON(key,fallback){ try{const raw=localStorage.getItem(key); return raw?JSON.parse(raw):fallback;}catch(e){return fallback;} }
function saveJSON(key,obj){ try{localStorage.setItem(key,JSON.stringify(obj));}catch(e){} }
let DB=loadJSON(STORE.DB,[]);

/* ========= audio ========= */
let ctx=null, mic=null, analyser=null, fftData=null;
let outMaster=null, busSleep=null, busNudge=null;
let sleepGraph=null, currentSleep="OFF";
let nudgeNextT=0;

function ensureAudio(){
  if(ctx) return;
  const AC=window.AudioContext||window.webkitAudioContext;
  if(!AC) throw new Error("AudioContext unsupported");
  ctx=new AC({latencyHint:"interactive"});
  outMaster=ctx.createGain(); outMaster.gain.value=0;
  busSleep=ctx.createGain(); busSleep.gain.value=0;
  busNudge=ctx.createGain(); busNudge.gain.value=0;
  busSleep.connect(outMaster);
  busNudge.connect(outMaster);
  outMaster.connect(ctx.destination);
  setPill(ui.pillAudio, ctx.state==="running"?"ok":"warn", "audio: "+ctx.state);
  ctx.onstatechange=()=>setPill(ui.pillAudio, ctx.state==="running"?"ok":"warn", "audio: "+ctx.state);
}
async function ensureMic(){
  if(mic) return;
  const stream = await navigator.mediaDevices.getUserMedia({audio:true});
  mic=ctx.createMediaStreamSource(stream);
  analyser=ctx.createAnalyser();
  analyser.fftSize=2048;
  analyser.smoothingTimeConstant=0.65;
  fftData=new Float32Array(analyser.frequencyBinCount);
  mic.connect(analyser);
  setPill(ui.pillMic,"ok","mic: on");
}
function masterOn(on){
  const t=ctx.currentTime;
  outMaster.gain.cancelScheduledValues(t);
  outMaster.gain.setValueAtTime(outMaster.gain.value,t);
  outMaster.gain.linearRampToValueAtTime(on?1:0, t+(on?0.8:0.35));
}
function setSleepBus(level){
  const t=ctx.currentTime;
  const vol=getSleepVol();
  busSleep.gain.cancelScheduledValues(t);
  busSleep.gain.setValueAtTime(busSleep.gain.value,t);
  busSleep.gain.linearRampToValueAtTime(level*vol, t+0.2);
}
function setNudgeBus(level){
  const t=ctx.currentTime;
  busNudge.gain.cancelScheduledValues(t);
  busNudge.gain.setValueAtTime(busNudge.gain.value,t);
  busNudge.gain.linearRampToValueAtTime(level, t+0.05);
}
function stopGraph(g){
  if(!g) return;
  try{g.stop();}catch(e){}
}
function whiteNoise(){
  const n=2*ctx.sampleRate;
  const b=ctx.createBuffer(1,n,ctx.sampleRate);
  const d=b.getChannelData(0);
  for(let i=0;i<n;i++) d[i]=(Math.random()*2-1)*0.35;
  const s=ctx.createBufferSource(); s.buffer=b; s.loop=true;
  return s;
}
function pinkNoise(){
  const n=2*ctx.sampleRate;
  const b=ctx.createBuffer(1,n,ctx.sampleRate);
  const out=b.getChannelData(0);
  let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
  for(let i=0;i<n;i++){
    const w=Math.random()*2-1;
    b0=0.99886*b0 + w*0.0555179;
    b1=0.99332*b1 + w*0.0750759;
    b2=0.96900*b2 + w*0.1538520;
    b3=0.86650*b3 + w*0.3104856;
    b4=0.55*b4 + w*0.5329522;
    b5=-0.7616*b5 - w*0.0168980;
    const p=b0+b1+b2+b3+b4+b5+b6 + w*0.5362;
    b6=w*0.115926;
    out[i]=p*0.08;
  }
  const s=ctx.createBufferSource(); s.buffer=b; s.loop=true;
  return s;
}
function brownNoise(){
  const n=2*ctx.sampleRate;
  const b=ctx.createBuffer(1,n,ctx.sampleRate);
  const out=b.getChannelData(0);
  let last=0;
  for(let i=0;i<n;i++){
    const w=Math.random()*2-1;
    last=clamp(last+0.02*w,-1,1);
    out[i]=last*0.32;
  }
  const s=ctx.createBufferSource(); s.buffer=b; s.loop=true;
  return s;
}
function softPad(){
  const g=ctx.createGain(); g.gain.value=0.25;
  const mix=ctx.createGain(); mix.gain.value=0.22;
  const base=110;
  const oscs=[base, base*5/4, base*3/2].map(f=>{ const o=ctx.createOscillator(); o.type="sine"; o.frequency.value=f; return o; });
  oscs.forEach(o=>o.connect(mix));
  mix.connect(g);
  return {node:g, start:()=>oscs.forEach(o=>o.start()), stop:()=>oscs.forEach(o=>o.stop())};
}
function buildSleep(name){
  const out=ctx.createGain(); out.gain.value=1;
  const main=ctx.createGain(); main.gain.value=1;
  main.connect(out);

  const swell=ctx.createOscillator(); swell.type="sine"; swell.frequency.value=0.09;
  const swellG=ctx.createGain(); swellG.gain.value=0.22;
  const swellAmp=ctx.createGain(); swellAmp.gain.value=0.72;
  swell.connect(swellG); swellG.connect(swellAmp.gain);
  swellAmp.connect(main);

  const sources=[];
  let pad=null;
  if(name==="OCEAN_SOFT"||name==="OCEAN_PAD"){
    const b=brownNoise(); const p=pinkNoise();
    b.connect(swellAmp); p.connect(swellAmp); sources.push(b,p);
    if(name==="OCEAN_PAD"){ pad=softPad(); pad.node.connect(swellAmp); }
  }else if(name==="RAIN_SOFT"){
    const base=pinkNoise(); const rain=whiteNoise();
    const rHP=ctx.createBiquadFilter(); rHP.type="highpass"; rHP.frequency.value=650;
    const rG=ctx.createGain(); rG.gain.value=0.22;
    base.connect(swellAmp);
    rain.connect(rHP); rHP.connect(rG); rG.connect(swellAmp);
    sources.push(base,rain);
  }else if(name==="PINK_SOFT"){
    const p=pinkNoise(); p.connect(swellAmp); sources.push(p);
  }
  return {
    node:out,
    start:()=>{ swell.start(); sources.forEach(s=>s.start()); if(pad) pad.start(); },
    stop:()=>{ try{swell.stop();}catch(e){} sources.forEach(s=>{try{s.stop();}catch(e){}}); if(pad) pad.stop(); }
  };
}
function applySleep(name){
  if(!ctx) return;
  if(name===currentSleep && sleepGraph) return;
  if(sleepGraph) stopGraph(sleepGraph);
  if(name==="OFF"){ currentSleep="OFF"; setSleepBus(0); return; }
  sleepGraph=buildSleep(name);
  sleepGraph.node.connect(busSleep);
  sleepGraph.start();
  currentSleep=name;
}
function scheduleNudge(pattern, intensity){
  const t0=ctx.currentTime+0.01;
  const osc=ctx.createOscillator();
  osc.type="sine"; osc.frequency.value=180;
  const gain=ctx.createGain();
  gain.gain.setValueAtTime(0, t0);
  const A=clamp(0.08+0.32*intensity,0.06,0.40);
  gain.gain.linearRampToValueAtTime(A, t0+0.03);
  gain.gain.linearRampToValueAtTime(0, t0+0.18);

  const pan=ctx.createStereoPanner();
  let p=0;
  if(pattern==="NUDGE_LEFT") p=-0.85;
  else if(pattern==="NUDGE_RIGHT") p=+0.85;
  else if(pattern==="NUDGE_ALT") p=((Math.floor(ctx.currentTime*2)%2)===0)?-0.85:+0.85;
  else p=0;
  pan.pan.setValueAtTime(p, t0);

  const nz=pinkNoise();
  const nzG=ctx.createGain(); nzG.gain.value=0.035*intensity;

  osc.connect(gain); gain.connect(pan); pan.connect(busNudge);
  nz.connect(nzG); nzG.connect(busNudge);

  osc.start(t0); osc.stop(t0+0.22);
  nz.start(t0); nz.stop(t0+0.22);
}

/* ========= motion ========= */
let motion={enabled:false, permitted:false, tiltLR:0, rms:0, moved:false, turnEvent:false, _prevTilt:0};
function computeTiltLR(gx,gy,gz){
  const denom=Math.max(1e-6, Math.sqrt(gx*gx+gy*gy+gz*gz));
  return clamp(gx/denom, -1, 1);
}
function onMotion(e){
  if(!motion.enabled) return;
  const ag=e.accelerationIncludingGravity;
  if(ag){
    const tilt=computeTiltLR(ag.x??0, ag.y??0, ag.z??0);
    motion.tiltLR=tilt;
    const prev=motion._prevTilt;
    if(Math.abs(prev)>0.25 && Math.abs(tilt)>0.25 && (prev*tilt<0)) motion.turnEvent=true;
    motion._prevTilt=tilt;
  }
  const a=e.acceleration;
  if(a){
    const inst=Math.sqrt((a.x??0)**2+(a.y??0)**2+(a.z??0)**2);
    motion.rms=0.90*motion.rms+0.10*inst;
    motion.moved=motion.rms>0.25;
  }
}
async function requestMotionPerm(){
  try{
    if(typeof DeviceMotionEvent!=="undefined" && typeof DeviceMotionEvent.requestPermission==="function"){
      const res=await DeviceMotionEvent.requestPermission();
      motion.permitted=(res==="granted");
    }else{
      motion.permitted=true;
    }
    if(motion.permitted){
      window.addEventListener("devicemotion", onMotion, {passive:true});
      setPill(ui.pillMotion,"ok","motion: on");
    }else{
      setPill(ui.pillMotion,"warn","motion: denied");
    }
  }catch(e){
    setPill(ui.pillMotion,"warn","motion: error");
    D("Motion error: "+(e?.message||e));
  }
}

/* ========= features ========= */
function computeFeatures(){
  analyser.getFloatFrequencyData(fftData);
  const sr=ctx.sampleRate, nyq=sr/2, N=fftData.length;
  let sumP=0,sumF=0,geom=0,count=0;
  let eL=0,eM=0,eH=0,peakP=0;
  for(let i=0;i<N;i++){
    const f=(i/N)*nyq;
    const db=fftData[i];
    const p=Math.pow(10,(db/10));
    const pC=Math.max(1e-12,p);
    sumP+=pC; sumF+=f*pC; geom+=Math.log(pC); count++;
    if(pC>peakP) peakP=pC;
    if(f>=60 && f<200) eL+=pC;
    else if(f>=200 && f<800) eM+=pC;
    else if(f>=800 && f<2500) eH+=pC;
  }
  const centroid=sumP>0?sumF/sumP:0;
  const flatness=Math.exp(geom/count)/(sumP/count);
  const meanP=sumP/Math.max(1,count);
  const periodicity=clamp((peakP/Math.max(1e-12,meanP))/20,0,1);
  const norm=(x)=>clamp(x/Math.max(1e-9,sumP),0,1);
  return {nl:norm(eL), nm:norm(eM), nh:norm(eH), centroid, flatness:clamp(flatness,0,1), periodicity};
}
function computeY(f){
  let y=0;
  y += 0.55*f.nl + 0.35*f.nm - 0.10*f.nh;
  y += 0.55*f.periodicity;
  y += 0.15*(1-f.flatness);
  return Math.round(clamp(y,0,1)*255);
}

/* ========= buffers / y* ========= */
let bufS=[],bufM=[],bufL=[],budgetBuf=[],duBuf=[];
function pushBuf(buf, win, s){ buf.push(s); const t=s.t; while(buf.length && (t-buf[0].t)>win) buf.shift(); }
function phiFrom(buf,thr){
  let total=0,sumY=0,snoreT=0;
  for(const s of buf){ total+=s.dt; sumY+=s.Y*s.dt; if(s.Y>thr) snoreT+=s.dt; }
  return {Ymean: total>0?sumY/total:0, snoreRatio: total>0?snoreT/total:0};
}
function pushBudget(t,dt,u){ budgetBuf.push({t,dt,u2:(u*u)*dt}); while(budgetBuf.length && (t-budgetBuf[0].t)>CFG.BUDGET_WIN) budgetBuf.shift(); }
function budgetUsed(){ let s=0; for(const x of budgetBuf) s+=x.u2; return s; }
function pushDu(t,dt,absDu){ duBuf.push({t,dt,val:absDu*dt}); while(duBuf.length && (t-duBuf[0].t)>CFG.DU_WIN) duBuf.shift(); }
function duUsed(){ let s=0; for(const x of duBuf) s+=x.val; return s; }

function estimateStage(phiM,y){
  const a=clamp(phiM.Ymean/255,0,1);
  const b=clamp(phiM.snoreRatio,0,1);
  const z=0.7*a+0.9*b+0.3*clamp(y/255,0,1);
  if(z<0.28) return "CALM";
  if(z<0.55) return "MIXED";
  return "DIST";
}
let sleepLatencySec=null, onsetStable=0;
function updateSleepLatency(phiM,t,dt){
  if(sleepLatencySec!=null) return;
  const thr=getTHR();
  const asleepish=(phiM.Ymean<thr*0.95)&&(phiM.snoreRatio<0.12)&&(busNudge.gain.value<getCap()*0.25);
  onsetStable = asleepish ? (onsetStable+dt) : Math.max(0,onsetStable-0.5*dt);
  if(onsetStable>=180) sleepLatencySec=Math.round(t-session.t0);
}
function updatePhase(phiM,phiL){
  if(!running){ phase="IDLE"; return; }
  if(session && session.inEvent){ phase="EVENT"; return; }
  if(sleepLatencySec==null){ phase="ONSET"; return; }
  const arousal=(duUsed()>0.35)&&(stage!=="CALM");
  if(arousal){ phase="AROUSAL"; return; }
  const stable=(phiL.snoreRatio<0.12)&&(phiM.snoreRatio<0.20)&&(stage==="CALM"||stage==="MIXED");
  phase=stable?"STABLE":"EVENT";
}
function tauOf(phiS,phiM,phiL){
  const cap=getCap();
  const bNorm=clamp(budgetUsed()/Math.max(1e-9,(CFG.BUDGET_WIN*cap*cap*0.25)),0,2);
  const duNorm=clamp(duUsed()/1.2,0,2);
  let tau=2.4;
  tau*=(1+0.9*phiM.snoreRatio);
  tau*=(1+0.6*(bNorm/2));
  tau*=(1+0.9*(duNorm/2));
  if(phase==="ONSET") tau*=1.35;
  if(phase==="AROUSAL") tau*=1.55;
  if(phase==="STABLE") tau*=1.15;
  return clamp(tau,0.8,7.5);
}
function computeYStar(elapsed,startY,phiS,phiM,phiL){
  const thr=getTHR();
  const tau=tauOf(phiS,phiM,phiL);
  const k=1/Math.max(0.25,tau);
  let ys=thr+(startY-thr)*Math.exp(-k*elapsed);
  ys=Math.max(thr,ys);
  if(phase==="ONSET"||phase==="AROUSAL") ys=Math.max(thr, thr+0.30*(startY-thr));
  return {ys,tau};
}

/* ========= IF probe (minimal keep) ========= */
let probe={enabled:false, perHour:0, hourStart:0, inProbe:false, tEnd:0, accE:0};
function resetProbeHour(){
  const w=wallNow();
  if(probe.hourStart===0) probe.hourStart=w;
  if(w-probe.hourStart>=3600*1000){ probe.hourStart=w; probe.perHour=0; }
}
function canProbe(){
  if(!probe.enabled) return false;
  if(sleepLatencySec==null) return false;
  if(!(phase==="STABLE"&&stage==="CALM")) return false;
  resetProbeHour();
  if(probe.perHour>=CFG.PROBE_MAX_PER_H) return false;
  if(probe.inProbe) return false;
  return true;
}

/* ========= scope ========= */
const cCtx=ui.cvs.getContext("2d");
let bufIn=new Array(CFG.SCOPE_N).fill(0);
let bufStar=new Array(CFG.SCOPE_N).fill(0);
let bufU=new Array(CFG.SCOPE_N).fill(0);
function drawScope(y,yStar,u,thr){
  const w=ui.cvs.width=ui.cvs.offsetWidth;
  const h=ui.cvs.height=ui.cvs.offsetHeight;
  cCtx.clearRect(0,0,w,h);
  bufIn.push(y); bufIn.shift();
  bufStar.push(yStar); bufStar.shift();
  bufU.push(u*255); bufU.shift();

  const yT=h-(thr/255)*h;
  cCtx.strokeStyle="#333"; cCtx.setLineDash([5,5]);
  cCtx.beginPath(); cCtx.moveTo(0,yT); cCtx.lineTo(w,yT); cCtx.stroke();
  cCtx.setLineDash([]);

  cCtx.strokeStyle="var(--snore)"; cCtx.lineWidth=1; cCtx.beginPath();
  for(let i=0;i<CFG.SCOPE_N;i++){
    const xx=i/(CFG.SCOPE_N-1)*w;
    const yy=h-(bufIn[i]/255)*h;
    if(i===0) cCtx.moveTo(xx,yy); else cCtx.lineTo(xx,yy);
  }
  cCtx.stroke();

  cCtx.strokeStyle="var(--target)"; cCtx.lineWidth=2; cCtx.beginPath();
  for(let i=0;i<CFG.SCOPE_N;i++){
    const xx=i/(CFG.SCOPE_N-1)*w;
    const yy=h-(bufStar[i]/255)*h;
    if(i===0) cCtx.moveTo(xx,yy); else cCtx.lineTo(xx,yy);
  }
  cCtx.stroke();

  if(Math.max(...bufU)>2){
    cCtx.fillStyle="rgba(255,59,48,0.22)";
    cCtx.beginPath(); cCtx.moveTo(0,h);
    for(let i=0;i<CFG.SCOPE_N;i++){
      const xx=i/(CFG.SCOPE_N-1)*w;
      const yy=h-(bufU[i]/255)*h;
      cCtx.lineTo(xx,yy);
    }
    cCtx.lineTo(w,h); cCtx.closePath(); cCtx.fill();
  }
}

/* ========= simulate snore ========= */
let simulate=false;
ui.btnSim.addEventListener("pointerdown",(e)=>{e.preventDefault(); simulate=true; ui.btnSim.classList.add("active");});
ui.btnSim.addEventListener("pointerup",(e)=>{e.preventDefault(); simulate=false; ui.btnSim.classList.remove("active");});
ui.btnSim.addEventListener("pointercancel",()=>{simulate=false; ui.btnSim.classList.remove("active");});
document.addEventListener("pointerup",()=>{simulate=false; ui.btnSim.classList.remove("active");});

/* ========= session ========= */
let session=null, currentCIEU=null;

/* ========= main loop ========= */
let lastTick=0, t=0, dt=1/CFG.LOGIC_HZ;
let ambientYmean=0, ambientN=0, dynThr=null, state="IDLE";
let pidI=0, lastU=0;
let opt={active:false,tEnd:0,x:null,level:"SOFT",actionKey:"",token:"NUDGE_ALT",rho:0, stats:{sumT:0,E_delta:0,sumU:0,uPeak:0,strong:0}};
let lastSleepDecisionT=0, autoSleep="OCEAN_SOFT";
let strongTimes=[];

function sleepBase(){
  if(phase==="ONSET") return 0.78;
  const elapsed = t - session.t0;
  if(elapsed > CFG.ONSET_DUCK_AFTER) return CFG.ONSET_BG;
  return 0.50;
}
function beginOption(t,x){
  opt.active=true;
  opt.tEnd=t+getOptSec();
  opt.stats={sumT:0,E_delta:0,sumU:0,uPeak:0,strong:0};
  // simple level pick
  opt.level="NORMAL";
  const pick="NUDGE_ALT::0.00";
  opt.actionKey=pick;
  const p=parseActionKey(pick);
  opt.token=p.tok; opt.rho=p.rho;
}
function endOption(){ opt.active=false; motion.turnEvent=false; }

function applySafety(uEff, cap, t, dt){
  let u=clamp(uEff,0,cap);
  const du=u-lastU;
  const absDu=Math.abs(du);
  if(du>CFG.MAX_DU) u=lastU+CFG.MAX_DU;
  if(du<-CFG.MAX_DU) u=lastU-CFG.MAX_DU;
  pushDu(t,dt,absDu);
  if(phase==="ONSET") u*=0.72;
  if(phase==="AROUSAL") u*=0.60;
  lastU=u;
  return u;
}

function loop(){
  if(!running) return;
  const tNow=nowMs()/1000;
  dt=(lastTick>0)?(tNow-lastTick):(1/CFG.LOGIC_HZ);
  lastTick=tNow;
  t=tNow;

  const feat=computeFeatures();
  let Y=computeY(feat);

  const thr=getTHR();
  pushBuf(bufS,CFG.PHI_S,{t,dt,Y});
  pushBuf(bufM,CFG.PHI_M,{t,dt,Y});
  pushBuf(bufL,CFG.PHI_L,{t,dt,Y});
  const phiS=phiFrom(bufS,thr), phiM=phiFrom(bufM,thr), phiL=phiFrom(bufL,thr);

  stage=estimateStage(phiM,Y);
  updateSleepLatency(phiM,t,dt);
  updatePhase(phiM,phiL);

  if(state==="CALIB"){
    ambientN++;
    ambientYmean += (Y-ambientYmean)/Math.max(1,ambientN);
    if(nowMs() - session.calibStart > CFG.CALIB_MS){
      dynThr = Math.max(thr, Math.round(ambientYmean + CFG.THR_MARGIN));
      session.dynThr = dynThr;
      session.ambientYmean = ambientYmean;
      state="RUN";
    }
  }

  const sleepName = ui.sleepSel.value==="AUTO" ? "OCEAN_SOFT" : ui.sleepSel.value;
  if(sleepName==="OFF"){ applySleep("OFF"); setSleepBus(0); }
  else { applySleep(sleepName); setSleepBus(sleepBase()); }

  const useThr = (state==="RUN" && dynThr!=null) ? dynThr : thr;
  const onsetDetectThr = Math.max(thr*0.85, (session.ambientYmean ?? ambientYmean) + 10);
  const detectThr = (phase==="ONSET") ? Math.min(useThr, onsetDetectThr) : useThr;

  if(simulate) Y = Math.max(Y, detectThr + 50);
  const wantEvent = (Y>detectThr) || simulate;

  if(!session.inEvent && wantEvent){
    session.inEvent=true;
    session.eventT0=t;
    session.eventStartY=Y;
    phase="EVENT";
    nudgeNextT = ctx.currentTime;
    startCIEU(t, ctxVec(phiS,phiM,phiL), Y, phiS,phiM,phiL, opt);
  }
  if(session.inEvent && !wantEvent){
    if(session.below==null) session.below=t;
    if(t-session.below>2){
      session.inEvent=false; session.below=null;
      finishCIEU(t);
    }
  } else {
    session.below=null;
  }

  const yStarObj = session.inEvent ? computeYStar(t-session.eventT0, session.eventStartY, phiS,phiM,phiL)
                                   : computeYStar(0, Y, phiS,phiM,phiL);
  const Ystar=yStarObj.ys;

  // u
  let u=0;
  const mode=getMode();
  if(mode==="monitor"){
    u=0; setNudgeBus(0);
  }else{
    const e = Math.max(0, clamp((Y-Ystar)/255,-1,1));
    const kp=0.40, ki=0.04;
    pidI = clamp(pidI + e*dt, 0, 0.9);
    const uPID = clamp(kp*e + ki*pidI, 0, 1);
    const cap = getCap();
    u = applySafety(uPID, cap, t, dt);
    setNudgeBus(Math.min(u,0.35));
    if(session.inEvent && u>0.03){
      const gap = clamp(CFG.NUDGE_MAX_GAP - u*(CFG.NUDGE_MAX_GAP-CFG.NUDGE_MIN_GAP), CFG.NUDGE_MIN_GAP, CFG.NUDGE_MAX_GAP);
      if(ctx.currentTime >= nudgeNextT){
        scheduleNudge("NUDGE_ALT", clamp(u,0,1));
        nudgeNextT = ctx.currentTime + gap;
      }
    }
    session.uEnergy += (u*u)*dt;
    session.uPeak = Math.max(session.uPeak,u);
  }

  // update pills + math
  ui.mPhase.textContent=phase;
  ui.mStage.textContent=stage;
  ui.mNudge.textContent=session.inEvent ? "NUDGE_ALT" : "--";
  ui.mMotion.textContent=(motion.enabled && motion.permitted)?"ON":"OFF";
  ui.mCieu.textContent=String(DB.filter(x=>x.type==="CIEU").length);
  ui.mDE.textContent="--";

  drawScope(Y,Ystar,u,useThr);

  setTimeout(loop, 1000/CFG.LOGIC_HZ);
}

/* ========= start/stop ========= */
async function start(){
  if(running) return;
  try{
    ensureAudio();
    await ctx.resume();
    setPill(ui.pillAudio, ctx.state==="running"?"ok":"warn", "audio: "+ctx.state);

    await ensureMic();

    motion.enabled = ui.useMotion.checked;
    if(motion.enabled && motion.permitted) setPill(ui.pillMotion,"ok","motion: on");
    else if(motion.enabled) setPill(ui.pillMotion,"warn","motion: need perm");
    else setPill(ui.pillMotion,"warn","motion: off");

    // init
    applySleep("OCEAN_SOFT");
    masterOn(true);
    setSleepBus(0.78);
    setNudgeBus(0);

    running=true;
    phase="ONSET"; stage="CALM"; state="CALIB";
    lastTick=0; pidI=0; lastU=0;
    bufS=[];bufM=[];bufL=[];budgetBuf=[];duBuf=[];strongTimes=[];
    ambientYmean=0;ambientN=0;dynThr=null;
    sleepLatencySec=null; onsetStable=0;
    session={ id:`sess_${Date.now()}`, t0:nowMs()/1000, calibStart:nowMs(), inEvent:false, eventT0:0, eventStartY:0, below:null,
      E_real:0,D_real:0,T_real:0,E_delta:0,D_delta:0,T_delta:0,uEnergy:0,uPeak:0,
      ambientYmean:null,dynThr:null
    };

    ui.btnActivate.textContent="STOP";
    ui.btnActivate.classList.add("primary");
    loop();
  }catch(e){
    alert("START FAIL: "+(e?.message||e));
    D("START FAIL: "+(e?.message||e));
  }
}
function stop(){
  if(!running) return;
  running=false;
  try{
    setNudgeBus(0); setSleepBus(0); masterOn(false);
  }catch(e){}
  ui.btnActivate.textContent="ACTIVATE";
  ui.btnActivate.classList.remove("primary");
}

ui.btnActivate.addEventListener("click", ()=> running ? stop() : start());
ui.btnPower.addEventListener("click", ()=> running ? stop() : start()); // fallback if you tap old UI (not shown)

ui.btnExportQuick.addEventListener("click", ()=>exportReport());
ui.btnExportReport.addEventListener("click", ()=>exportReport());
ui.btnExportLocal.addEventListener("click", ()=>exportLocal());
ui.btnSnapshot.addEventListener("click", ()=>saveSnapshot());

/* ========= self test ========= */
ui.btnSelfTest.addEventListener("click", async ()=>{
  try{
    alert("Protocol: "+location.protocol+"\nHost: "+location.host);
    const AC=window.AudioContext||window.webkitAudioContext;
    if(!AC){ alert("No AudioContext"); return; }
    const tctx=new AC();
    await tctx.resume();
    alert("AudioContext state="+tctx.state);
    const stream=await navigator.mediaDevices.getUserMedia({audio:true});
    alert("Mic OK, tracks="+stream.getTracks().length);
    stream.getTracks().forEach(t=>t.stop());
    await tctx.close();
  }catch(e){
    alert("SELF TEST FAIL: "+(e?.name||"")+" "+(e?.message||e));
    D("SELF TEST FAIL: "+(e?.name||"")+" "+(e?.message||e));
  }
});

/* ========= motion ========= */
ui.btnMotionPerm.addEventListener("click", async ()=>{ motion.enabled=true; ui.useMotion.checked=true; await requestMotionPerm(); });
ui.useMotion.addEventListener("change", ()=>{ motion.enabled=ui.useMotion.checked; if(!motion.enabled) setPill(ui.pillMotion,"warn","motion: off"); });

/* ========= exports ========= */
function exportReport(){
  const payload={type:"REPORT", session, savedAt:Date.now()};
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download=`SnoreField_v7_7_Report_${Date.now()}.json`; a.click();
  URL.revokeObjectURL(url);
}
function exportLocal(){
  const blob=new Blob([JSON.stringify(DB,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download=`SnoreField_v7_7_LOCAL_${Date.now()}.json`; a.click();
  URL.revokeObjectURL(url);
}
function saveSnapshot(){
  DB.push({type:"SNAPSHOT", session, savedAt:Date.now()});
  saveJSON(STORE.DB, DB);
  alert("Snapshot saved.");
}

/* ========= init pills ========= */
setPill(ui.pillAudio,"warn","audio: suspended");
setPill(ui.pillMic,"warn","mic: off");
setPill(ui.pillMotion,"warn","motion: off");
D("Loaded v7.7. ACTIVATE button is always at bottom. SELF TEST is always visible. If nothing works, you're on wrong URL or JS disabled.");
</script>
</body>
</html>
