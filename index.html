<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>SnoreField v8.0 — WaveFrame CIEU + RL + IFProbe + Y*</title>
  <style>
    :root{
      --bg:#050505; --panel:#0b0b0b; --line:#2a2a2a;
      --txt:#eaeaea; --muted:#9a9a9a; --accent:#0a84ff;
      --ok:#31c48d; --warn:#f6ad55; --bad:#fc8181;
      --y:#00f2ff; --ystar:#ff9f0a; --u:#ff3b30;
    }
    html,body{
      height:100%; margin:0; background:var(--bg); color:var(--txt);
      font-family:ui-monospace, Menlo, Monaco, Consolas, monospace;
    }
    body{overflow:auto; -webkit-overflow-scrolling:touch;}

    .scope-wrap{width:100%; height:260px; background:#000; border-bottom:1px solid #222; position:relative;}
    canvas{width:100%; height:100%; display:block;}

    .legend{
      position:absolute; top:10px; left:10px; font-size:10px;
      display:flex; gap:14px; pointer-events:none; opacity:.95;
    }
    .dot{width:8px; height:8px; border-radius:50%; display:inline-block; margin-right:4px;}
    .overlay{
      position:absolute; top:34px; left:10px; font-size:10px;
      color:#b5b5b5; line-height:1.55; pointer-events:none;
    }
    .hi{color:var(--accent); font-weight:800;}

    .top-right{
      position:absolute; top:10px; right:10px;
      display:flex; flex-direction:column; gap:6px; align-items:flex-end;
    }
    .pill{
      padding:4px 9px; border:1px solid #333; border-radius:999px;
      font-size:10px; color:#bbb; background:rgba(0,0,0,.35);
    }
    .pill.ok{border-color:rgba(49,196,141,.6); color:rgba(49,196,141,.95);}
    .pill.warn{border-color:rgba(246,173,85,.6); color:rgba(246,173,85,.95);}
    .pill.bad{border-color:rgba(252,129,129,.6); color:rgba(252,129,129,.95);}

    .toolbar{
      position:sticky; top:0; z-index:20;
      background:rgba(5,5,5,.92); backdrop-filter: blur(10px);
      border:1px solid var(--line); border-radius:14px;
      padding:10px; margin:12px 12px 10px;
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .btn{
      background:#0b0b0b; border:1px solid #444; color:var(--txt);
      border-radius:12px; padding:10px 12px; font-weight:900;
      cursor:pointer; user-select:none;
    }
    .btn:active{transform:scale(.98);}
    .btn.primary{border-color:rgba(10,132,255,.7); color:#dbe9ff;}
    .btn.danger{border-color:rgba(255,59,48,.55); color:#ffe2e0;}
    .btn.gray{border-color:#666; color:#ddd;}
    .btn.green{border-color:#2b5; color:#cfe;}
    .btn.blue{border-color:#59f; color:#def;}
    .btn.amber{border-color:#fa3; color:#ffe;}

    .grid{
      display:grid; gap:10px; grid-template-columns: 1fr 1fr; margin:0 12px;
    }
    .card{background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:10px;}
    .label{
      font-size:11px; color:var(--muted);
      display:flex; justify-content:space-between; margin-bottom:6px;
    }
    select, input[type="range"]{
      width:100%;
      background:#0c0c0c; border:1px solid #333; border-radius:12px;
      padding:10px; color:#ddd; outline:none;
    }
    input[type="range"]{padding:0; height:36px;}
    .toggles{display:flex; gap:14px; flex-wrap:wrap; margin-top:6px;}
    .toggle{display:flex; gap:8px; align-items:center; font-size:11px; color:#aaa;}
    .toggle input{transform:scale(1.1);}

    details{margin:12px; border:1px solid var(--line); border-radius:14px; background:#0a0a0a; padding:10px;}
    summary{cursor:pointer; color:#9a9a9a; font-size:11px; font-weight:800;}
    pre{
      margin:8px 0 0; padding:10px; border-radius:12px; background:#050505;
      border:1px solid #222; max-height:280px; overflow:auto;
      font-size:10px; color:#9aa; white-space:pre-wrap;
    }
    .hidden{display:none;}
  </style>
</head>
<body>

<div class="scope-wrap">
  <div class="legend">
    <div><span class="dot" style="background:var(--y)"></span>Y</div>
    <div><span class="dot" style="background:var(--ystar)"></span>Y*</div>
    <div><span class="dot" style="background:var(--u)"></span>u</div>
  </div>

  <div class="overlay">
    Phase: <span class="hi" id="oPhase">IDLE</span> | Stage: <span class="hi" id="oStage">CALM</span><br>
    Level: <span class="hi" id="oLevel">--</span> | Action: <span class="hi" id="oAction">--</span><br>
    IF ΔE: <span class="hi" id="oDE">--</span> | Turns: <span class="hi" id="oTurns">0</span><br>
    Motion: <span class="hi" id="oMotion">OFF</span>
  </div>

  <div class="top-right">
    <div class="pill warn" id="pillAudio">audio: suspended</div>
    <div class="pill warn" id="pillMic">mic: off</div>
    <div class="pill warn" id="pillMotion">motion: off</div>
  </div>

  <canvas id="scope"></canvas>
</div>

<div class="toolbar">
  <div class="row">
    <button class="btn primary" id="btnActivate">ACTIVATE</button>
    <button class="btn gray" id="btnSelfTest">SELF TEST</button>
    <button class="btn gray" id="btnMotionPerm">MOTION PERM</button>
    <button class="btn danger" id="btnSim">HOLD: SIMULATE SNORE</button>
    <label class="toggle"><input type="checkbox" id="showDebug"> Show Debug</label>
  </div>
  <div class="row" style="margin-top:8px;">
    <button class="btn green" id="btnExportReport">EXPORT REPORT</button>
    <button class="btn blue" id="btnExportLocal">EXPORT LOCAL DB</button>
    <button class="btn amber" id="btnSnapshot">SAVE SNAPSHOT</button>
    <button class="btn gray" id="btnClearLocal">CLEAR LOCAL</button>
  </div>
</div>

<div class="grid">
  <div class="card">
    <div class="label"><span>MODE</span><span id="vMode">AUTO</span></div>
    <select id="modeSel">
      <option value="auto">AUTO</option>
      <option value="monitor">MONITOR (S0)</option>
      <option value="gentle">GENTLE</option>
      <option value="standard">STANDARD</option>
    </select>
  </div>

  <div class="card">
    <div class="label"><span>SLEEP</span><span id="vSleep">AUTO</span></div>
    <select id="sleepSel">
      <option value="AUTO">AUTO</option>
      <option value="OCEAN_SOFT">OCEAN_SOFT</option>
      <option value="OCEAN_PAD">OCEAN_PAD</option>
      <option value="RAIN_SOFT">RAIN_SOFT</option>
      <option value="PINK_SOFT">PINK_SOFT</option>
      <option value="OFF">OFF</option>
    </select>
  </div>

  <div class="card">
    <div class="label"><span>CAP</span><span id="vCap">0.10</span></div>
    <input type="range" id="cap" min="0" max="0.20" step="0.005" value="0.10">
  </div>

  <div class="card">
    <div class="label"><span>SLEEP VOL</span><span id="vSleepVol">0.70</span></div>
    <input type="range" id="sleepVol" min="0" max="1" step="0.02" value="0.70">
  </div>

  <div class="card">
    <div class="label"><span>THR</span><span id="vThr">80</span></div>
    <input type="range" id="thr" min="30" max="210" step="1" value="80">
  </div>

  <div class="card">
    <div class="label"><span>OPTION (sec)</span><span id="vOpt">15</span></div>
    <input type="range" id="opt" min="10" max="30" step="1" value="15">
  </div>

  <div class="card">
    <div class="label"><span>α</span><span id="vAlpha">0.65</span></div>
    <input type="range" id="alpha" min="0.05" max="2.5" step="0.05" value="0.65">
  </div>

  <div class="card">
    <div class="label"><span>SQ WEIGHT</span><span id="vSqw">1.4</span></div>
    <input type="range" id="sqw" min="0.7" max="2.5" step="0.1" value="1.4">
  </div>

  <div class="card" style="grid-column:1 / -1;">
    <div class="toggles">
      <label class="toggle"><input type="checkbox" id="useMotion"> Use DeviceMotion</label>
      <label class="toggle"><input type="checkbox" id="ifProbe"> IF Probe L1</label>
      <label class="toggle"><input type="checkbox" id="autoBackup" checked> Auto Backup</label>
    </div>
  </div>
</div>

<details id="debugPanel" class="hidden" open>
  <summary>Debug / Errors</summary>
  <pre id="debug"></pre>
</details>

<script>
/* ================= CFG / Helpers / UI ==================== */
const CFG = {
  LOGIC_HZ: 20,
  SCOPE_N: 360,
  CALIB_MS: 8000,
  THR_MARGIN: 15,
  MASTER_FADE_IN: 0.7,
  ONSET_BG_AFTER: 15*60,
  ONSET_BG_LEVEL: 0.35,
  PHI_S: 8,
  PHI_M: 60,
  PHI_L: 600,
  DU_WIN: 30,
  BUDGET_WIN: 600,
  MAX_DU: 0.015,
  STRONG_MAX_PER_MIN: 3,
  NUDGE_MIN_GAP: 0.8,
  NUDGE_MAX_GAP: 2.2,
  PROBE_MAX_PER_H: 5,
  PROBE_ABORT_MARGIN: 35
};

const $ = (id)=>document.getElementById(id);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const nowMs=()=>performance.now();
const wallNow=()=>Date.now();

const debugEl=$("debug");
const log=(s)=>{ debugEl.textContent = String(s)+"\n\n"+debugEl.textContent; };
window.addEventListener("error",(e)=>{ log(`[JS ERROR] ${e.message} @ ${e.filename}:${e.lineno}:${e.colno}`); });

const ui={
  btnActivate:$("btnActivate"),
  btnSelfTest:$("btnSelfTest"),
  btnMotionPerm:$("btnMotionPerm"),
  btnSim:$("btnSim"),
  btnExportReport:$("btnExportReport"),
  btnExportLocal:$("btnExportLocal"),
  btnSnapshot:$("btnSnapshot"),
  btnClearLocal:$("btnClearLocal"),
  showDebug:$("showDebug"),
  debugPanel:$("debugPanel"),

  modeSel:$("modeSel"),
  sleepSel:$("sleepSel"),
  cap:$("cap"),
  sleepVol:$("sleepVol"),
  thr:$("thr"),
  opt:$("opt"),
  alpha:$("alpha"),
  sqw:$("sqw"),

  vMode:$("vMode"), vSleep:$("vSleep"), vCap:$("vCap"), vSleepVol:$("vSleepVol"),
  vThr:$("vThr"), vOpt:$("vOpt"), vAlpha:$("vAlpha"), vSqw:$("vSqw"),

  useMotion:$("useMotion"),
  ifProbe:$("ifProbe"),
  autoBackup:$("autoBackup"),

  pillAudio:$("pillAudio"),
  pillMic:$("pillMic"),
  pillMotion:$("pillMotion"),

  oPhase:$("oPhase"),
  oStage:$("oStage"),
  oLevel:$("oLevel"),
  oAction:$("oAction"),
  oDE:$("oDE"),
  oTurns:$("oTurns"),
  oMotion:$("oMotion"),

  cvs:$("scope")
};

function setPill(el, kind, text){
  el.classList.remove("ok","warn","bad");
  el.classList.add(kind);
  el.textContent=text;
}
function syncUI(){
  ui.vMode.textContent = ui.modeSel.value.toUpperCase();
  ui.vSleep.textContent = ui.sleepSel.value;
  ui.vCap.textContent = (+ui.cap.value).toFixed(2);
  ui.vSleepVol.textContent = (+ui.sleepVol.value).toFixed(2);
  ui.vThr.textContent = ui.thr.value;
  ui.vOpt.textContent = ui.opt.value;
  ui.vAlpha.textContent = (+ui.alpha.value).toFixed(2);
  ui.vSqw.textContent = (+ui.sqw.value).toFixed(1);
}
["input","change"].forEach(ev=>{
  ui.modeSel.addEventListener(ev,syncUI);
  ui.sleepSel.addEventListener(ev,syncUI);
  ui.cap.addEventListener(ev,syncUI);
  ui.sleepVol.addEventListener(ev,syncUI);
  ui.thr.addEventListener(ev,syncUI);
  ui.opt.addEventListener(ev,syncUI);
  ui.alpha.addEventListener(ev,syncUI);
  ui.sqw.addEventListener(ev,syncUI);
});
syncUI();

ui.showDebug.addEventListener("change", ()=>{
  ui.debugPanel.classList.toggle("hidden", !ui.showDebug.checked);
});

function getTHR(){return parseInt(ui.thr.value,10);}
function getCap(){return parseFloat(ui.cap.value);}
function getSleepVol(){return parseFloat(ui.sleepVol.value);}
function getOptSec(){return parseFloat(ui.opt.value);}
function getAlpha(){return parseFloat(ui.alpha.value);}
function getSQW(){return parseFloat(ui.sqw.value);}

function getMode(phase, stage){
  const v=ui.modeSel.value;
  if(v!=="auto") return v;
  if(phase==="ONSET"||phase==="AROUSAL") return "gentle";
  if(stage==="CALM") return "gentle";
  return "standard";
}

/* Storage */
const STORE={DB:"snorefield_v8_db"};
function loadJSON(key,fallback){ try{const raw=localStorage.getItem(key); return raw?JSON.parse(raw):fallback;}catch(e){return fallback;} }
function saveJSON(key,obj){ try{localStorage.setItem(key,JSON.stringify(obj));}catch(e){} }
let DB=loadJSON(STORE.DB,[]);
function pushDB(item){
  DB.push(item);
  if(DB.length>5000) DB = DB.slice(DB.length-5000);
  saveJSON(STORE.DB, DB);
}

/* ============ L0 Audio / Mic ============ */
let ctx=null, mic=null, analyser=null, fftData=null;
let outMaster=null, busSleep=null, busNudge=null;
let sleepGraph=null, currentSleep="OFF";

function ensureAudio(){
  if(ctx) return;
  const AC=window.AudioContext||window.webkitAudioContext;
  if(!AC) throw new Error("AudioContext unsupported");
  ctx=new AC({latencyHint:"interactive"});
  outMaster=ctx.createGain(); outMaster.gain.value=0;
  busSleep=ctx.createGain(); busSleep.gain.value=0;
  busNudge=ctx.createGain(); busNudge.gain.value=0;
  busSleep.connect(outMaster);
  busNudge.connect(outMaster);
  outMaster.connect(ctx.destination);
  setPill(ui.pillAudio, ctx.state==="running"?"ok":"warn", "audio: "+ctx.state);
  ctx.onstatechange=()=>setPill(ui.pillAudio, ctx.state==="running"?"ok":"warn", "audio: "+ctx.state);
}
async function ensureMic(){
  if(mic) return;
  const stream=await navigator.mediaDevices.getUserMedia({audio:true});
  mic=ctx.createMediaStreamSource(stream);
  analyser=ctx.createAnalyser();
  analyser.fftSize=2048;
  analyser.smoothingTimeConstant=0.65;
  fftData=new Float32Array(analyser.frequencyBinCount);
  mic.connect(analyser);
  setPill(ui.pillMic,"ok","mic: on");
}
function masterOn(on){
  const t=ctx.currentTime;
  outMaster.gain.cancelScheduledValues(t);
  outMaster.gain.setValueAtTime(outMaster.gain.value,t);
  outMaster.gain.linearRampToValueAtTime(on?1:0, t+(on?CFG.MASTER_FADE_IN:0.35));
}
function setSleepBus(level){
  const t=ctx.currentTime;
  const vol=getSleepVol();
  busSleep.gain.cancelScheduledValues(t);
  busSleep.gain.setValueAtTime(busSleep.gain.value,t);
  busSleep.gain.linearRampToValueAtTime(level*vol, t+0.2);
}
function setNudgeBus(level){
  const t=ctx.currentTime;
  busNudge.gain.cancelScheduledValues(t);
  busNudge.gain.setValueAtTime(busNudge.gain.value,t);
  busNudge.gain.linearRampToValueAtTime(level, t+0.05);
}

/* Sleep sounds */
function whiteNoise(){
  const n=2*ctx.sampleRate;
  const b=ctx.createBuffer(1,n,ctx.sampleRate);
  const d=b.getChannelData(0);
  for(let i=0;i<n;i++) d[i]=(Math.random()*2-1)*0.35;
  const s=ctx.createBufferSource(); s.buffer=b; s.loop=true; return s;
}
function pinkNoise(){
  const n=2*ctx.sampleRate;
  const b=ctx.createBuffer(1,n,ctx.sampleRate);
  const out=b.getChannelData(0);
  let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
  for(let i=0;i<n;i++){
    const w=Math.random()*2-1;
    b0=0.99886*b0 + w*0.0555179;
    b1=0.99332*b1 + w*0.0750759;
    b2=0.96900*b2 + w*0.1538520;
    b3=0.86650*b3 + w*0.3104856;
    b4=0.55*b4 + w*0.5329522;
    b5=-0.7616*b5 - w*0.0168980;
    const p=b0+b1+b2+b3+b4+b5+b6 + w*0.5362;
    b6=w*0.115926;
    out[i]=p*0.08;
  }
  const s=ctx.createBufferSource(); s.buffer=b; s.loop=true; return s;
}
function brownNoise(){
  const n=2*ctx.sampleRate;
  const b=ctx.createBuffer(1,n,ctx.sampleRate);
  const out=b.getChannelData(0);
  let last=0;
  for(let i=0;i<n;i++){
    const w=Math.random()*2-1;
    last=clamp(last+0.02*w,-1,1);
    out[i]=last*0.32;
  }
  const s=ctx.createBufferSource(); s.buffer=b; s.loop=true; return s;
}
function softPad(){
  const g=ctx.createGain(); g.gain.value=0.25;
  const lp=ctx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=700;
  const mix=ctx.createGain(); mix.gain.value=0.22;
  const base=110;
  const freqs=[base, base*5/4, base*3/2];
  const oscs=freqs.map(f=>{const o=ctx.createOscillator(); o.type="sine"; o.frequency.value=f; return o;});
  oscs.forEach(o=>o.connect(mix));
  mix.connect(lp); lp.connect(g);
  return {node:g, start:()=>oscs.forEach(o=>o.start()), stop:()=>oscs.forEach(o=>o.stop())};
}
function buildSleep(name){
  const out=ctx.createGain(); out.gain.value=1;
  const main=ctx.createGain(); main.gain.value=1; main.connect(out);

  const swell=ctx.createOscillator(); swell.type="sine"; swell.frequency.value=0.09;
  const swellG=ctx.createGain(); swellG.gain.value=0.22;
  const swellAmp=ctx.createGain(); swellAmp.gain.value=0.72;
  swell.connect(swellG); swellG.connect(swellAmp.gain);
  swellAmp.connect(main);

  const sources=[]; let pad=null;
  if(name==="OCEAN_SOFT" || name==="OCEAN_PAD"){
    const b=brownNoise(); const p=pinkNoise();
    b.connect(swellAmp); p.connect(swellAmp);
    sources.push(b,p);
    if(name==="OCEAN_PAD"){ pad=softPad(); pad.node.connect(swellAmp); }
  } else if(name==="RAIN_SOFT"){
    const base=pinkNoise(); const rain=whiteNoise();
    const rHP=ctx.createBiquadFilter(); rHP.type="highpass"; rHP.frequency.value=650;
    const rG=ctx.createGain(); rG.gain.value=0.22;
    base.connect(swellAmp);
    rain.connect(rHP); rHP.connect(rG); rG.connect(swellAmp);
    sources.push(base,rain);
  } else if(name==="PINK_SOFT"){
    const p=pinkNoise(); p.connect(swellAmp); sources.push(p);
  }
  return {
    node: out,
    start: ()=>{ swell.start(); sources.forEach(s=>s.start()); if(pad) pad.start(); },
    stop:  ()=>{ try{swell.stop();}catch(e){} sources.forEach(s=>{try{s.stop();}catch(e){}}); if(pad) pad.stop(); }
  };
}
function applySleep(name){
  if(!ctx) return;
  if(name===currentSleep && sleepGraph) return;
  if(name==="OFF"){ currentSleep="OFF"; setSleepBus(0); return; }
  sleepGraph=buildSleep(name);
  sleepGraph.node.connect(busSleep);
  sleepGraph.start();
  currentSleep=name;
}

/* ============ DeviceMotion L0 ============ */
let motion={enabled:false, permitted:false, tiltLR:0, rms:0, moved:false, turnEvent:false, _prevTilt:0};
function computeTiltLR(gx,gy,gz){
  const denom=Math.max(1e-6, Math.sqrt(gx*gx+gy*gy+gz*gz));
  return clamp(gx/denom,-1,1);
}
function onMotion(e){
  if(!motion.enabled) return;
  const ag=e.accelerationIncludingGravity;
  if(ag){
    const tilt=computeTiltLR(ag.x||0, ag.y||0, ag.z||0);
    motion.tiltLR=tilt;
    const prev=motion._prevTilt;
    if(Math.abs(prev)>0.25 && Math.abs(tilt)>0.25 && (prev*tilt<0)) motion.turnEvent=true;
    motion._prevTilt=tilt;
  }
  const a=e.acceleration;
  if(a){
    const ax=a.x||0, ay=a.y||0, az=a.z||0;
    const inst=Math.sqrt(ax*ax+ay*ay+az*az);
    motion.rms=0.90*motion.rms + 0.10*inst;
    motion.moved = motion.rms>0.25;
  }
}
async function requestMotionPerm(){
  try{
    motion.enabled=true;
    ui.useMotion.checked=true;
    if(typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function"){
      const res=await DeviceMotionEvent.requestPermission();
      motion.permitted=(res==="granted");
    } else motion.permitted=true;

    if(motion.permitted){
      window.addEventListener("devicemotion", onMotion, {passive:true});
      setPill(ui.pillMotion,"ok","motion: on");
    } else {
      setPill(ui.pillMotion,"warn","motion: denied");
    }
  }catch(e){
    setPill(ui.pillMotion,"warn","motion: error");
    log("Motion perm error: "+(e?.message||e));
  }
}

/* ============ L1: Features -> Y（保持简化版逻辑） ============ */
function computeFeatures(){
  analyser.getFloatFrequencyData(fftData);
  const sr=ctx.sampleRate, nyq=sr/2, N=fftData.length;
  let sumP=0, geom=0, count=0;
  let eL=0,eM=0,eH=0,peakP=0;
  for(let i=0;i<N;i++){
    const f=(i/N)*nyq;
    const db=fftData[i];
    const p=Math.pow(10,(db/10));
    const pC=Math.max(1e-12,p);
    sumP+=pC; geom+=Math.log(pC); count++;
    if(pC>peakP) peakP=pC;
    if(f>=60 && f<250) eL+=pC;
    else if(f>=250 && f<800) eM+=pC;
    else if(f>=800 && f<2500) eH+=pC;
  }
  const flatness=Math.exp(geom/count)/(sumP/count);
  const meanP=sumP/Math.max(1,count);
  const periodicity=clamp((peakP/Math.max(1e-12,meanP))/15,0,1);
  const norm=(x)=>clamp(x/Math.max(1e-9,sumP),0,1);
  return {nl:norm(eL), nm:norm(eM), nh:norm(eH), flatness:clamp(flatness,0,1), periodicity};
}

function computeY(f){
  let y=0;
  const lowBand = f.nl + 0.5*f.nm;
  const snoreShape = 0.7*f.periodicity + 0.3*(1-f.flatness);
  y = 0.6*lowBand + 0.4*snoreShape;
  y = clamp(y,0,1);
  return Math.round(y*255);
}

/* ============ Φ / Phase / Y* ============ */
let bufS=[],bufM=[],bufL=[],budgetBuf=[],duBuf=[];
function pushBuf(buf,win,s){buf.push(s); const tt=s.t; while(buf.length && (tt-buf[0].t)>win) buf.shift();}
function phiFrom(buf,thr){
  let total=0,sumY=0,snoreT=0;
  for(const s of buf){total+=s.dt; sumY+=s.Y*s.dt; if(s.Y>thr) snoreT+=s.dt;}
  return {Ymean: total>0?sumY/total:0, snoreRatio: total>0?snoreT/total:0};
}
function pushBudget(t,dt,u){budgetBuf.push({t,dt,u2:(u*u)*dt}); while(budgetBuf.length && (t-budgetBuf[0].t)>CFG.BUDGET_WIN) budgetBuf.shift();}
function budgetUsed(){let s=0; for(const x of budgetBuf) s+=x.u2; return s;}
function pushDu(t,dt,absDu){duBuf.push({t,dt,val:absDu*dt}); while(duBuf.length && (t-duBuf[0].t)>CFG.DU_WIN) duBuf.shift();}
function duUsed(){let s=0; for(const x of duBuf) s+=x.val; return s;}

let phase="IDLE", stage="CALM";
function estimateStage(phiM,y){
  const a=clamp(phiM.Ymean/255,0,1);
  const b=clamp(phiM.snoreRatio,0,1);
  const z=0.7*a+0.9*b+0.3*clamp(y/255,0,1);
  if(z<0.28) return "CALM";
  if(z<0.55) return "MIXED";
  return "DIST";
}

let sleepLatencySec=null, onsetStable=0;
function updateSleepLatency(phiM,t,dt){
  if(sleepLatencySec!=null) return;
  const thr=getTHR();
  const asleepish=(phiM.Ymean<thr*0.95)&&(phiM.snoreRatio<0.12)&&(busNudge.gain.value<getCap()*0.25);
  onsetStable = asleepish ? (onsetStable+dt) : Math.max(0,onsetStable-0.5*dt);
  if(onsetStable>=180) sleepLatencySec=Math.round(t-session.t0);
}
function updatePhase(phiM,phiL){
  if(!running){ phase="IDLE"; return; }
  if(session && session.inEvent){ phase="EVENT"; return; }
  if(sleepLatencySec==null){ phase="ONSET"; return; }
  const arousal=(duUsed()>0.35)&&(stage!=="CALM");
  if(arousal){ phase="AROUSAL"; return; }
  const stable=(phiL.snoreRatio<0.12)&&(phiM.snoreRatio<0.20)&&(stage==="CALM"||stage==="MIXED");
  phase=stable?"STABLE":"EVENT";
}

function tauOf(phiS,phiM,phiL){
  const cap=getCap();
  const bNorm=clamp(budgetUsed()/Math.max(1e-9,(CFG.BUDGET_WIN*cap*cap*0.25)),0,2);
  const duNorm=clamp(duUsed()/1.2,0,2);
  let tau=2.4;
  tau*=(1+0.9*phiM.snoreRatio);
  tau*=(1+0.6*(bNorm/2));
  tau*=(1+0.9*(duNorm/2));
  if(phase==="ONSET") tau*=1.35;
  if(phase==="AROUSAL") tau*=1.55;
  if(phase==="STABLE") tau*=1.15;
  return clamp(tau,0.8,7.5);
}
function computeYStar(elapsed,startY,phiS,phiM,phiL){
  const thr=getTHR();
  const tau=tauOf(phiS,phiM,phiL);
  const k=1/Math.max(0.25,tau);
  let ys=thr+(startY-thr)*Math.exp(-k*elapsed);
  ys=Math.max(thr,ys);
  if(phase==="ONSET"||phase==="AROUSAL"){
    ys=Math.max(thr, thr+0.30*(startY-thr));
  }
  return {ys,tau};
}

/* ============ Safety DSL ============ */
let lastU=0;
let strongTimes=[];
function applySafety(uEff, cap, t, dt){
  let u=clamp(uEff,0,cap);
  const du=u-lastU;
  if(du>CFG.MAX_DU) u=lastU+CFG.MAX_DU;
  if(du<-CFG.MAX_DU) u=lastU-CFG.MAX_DU;
  pushDu(t,dt,Math.abs(du));

  const strong=u>0.75*cap;
  if(strong){
    const w=wallNow();
    strongTimes.push(w);
    strongTimes=strongTimes.filter(x=>w-x<=60*1000);
    if(strongTimes.length>CFG.STRONG_MAX_PER_MIN) u*=0.65;
  }
  if(phase==="ONSET") u*=0.72;
  if(phase==="AROUSAL") u*=0.60;

  lastU=u;
  return u;
}

/* ============ Nudge actuator ============ */
function scheduleNudge(pattern,intensity){
  const t0=ctx.currentTime+0.01;
  let freq = 180, attack = 0.03, release = 0.18;
  if(pattern === "NUDGE_BREATH"){
    freq = 90; attack = 0.08; release = 0.32;
  }
  const osc=ctx.createOscillator(); osc.type="sine"; osc.frequency.value=freq;
  const gain=ctx.createGain();
  gain.gain.setValueAtTime(0.0,t0);
  const A=clamp(0.08+0.32*intensity,0.06,0.40);
  gain.gain.linearRampToValueAtTime(A,t0+attack);
  gain.gain.linearRampToValueAtTime(0.0,t0+release);
  const pan=ctx.createStereoPanner();
  let p=0;
  if(pattern==="NUDGE_LEFT") p=-0.85;
  else if(pattern==="NUDGE_RIGHT") p=+0.85;
  else if(pattern==="NUDGE_ALT") p=((Math.floor(ctx.currentTime*2)%2)===0)?-0.85:+0.85;
  else p=0;
  pan.pan.setValueAtTime(p,t0);
  const nz=pinkNoise();
  const nzG=ctx.createGain(); nzG.gain.value=0.035*intensity;
  osc.connect(gain); gain.connect(pan); pan.connect(busNudge);
  nz.connect(nzG); nzG.connect(busNudge);
  osc.start(t0); osc.stop(t0+release);
  nz.start(t0); nz.stop(t0+release);
}

/* ============ RL: Options + Hierarchical LinUCB ============ */
function zeros(n){return Array.from({length:n},()=>0);}
function eye(n){const m=[]; for(let i=0;i<n;i++){const r=zeros(n); r[i]=1; m.push(r);} return m;}
function dot(a,b){let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s;}
function matVec(A,x){const y=zeros(A.length); for(let i=0;i<A.length;i++){let s=0; for(let j=0;j<x.length;j++) s+=A[i][j]*x[j]; y[i]=s;} return y;}
function quad(x,A){const Ax=matVec(A,x); return dot(x,Ax);}
function sherman(Ainv,x){
  const Ax=matVec(Ainv,x), denom=1+dot(x,Ax), n=x.length;
  const out=Array.from({length:n},()=>zeros(n));
  for(let i=0;i<n;i++) for(let j=0;j<n;j++) out[i][j]=Ainv[i][j]-(Ax[i]*Ax[j])/denom;
  return out;
}
class LinUCB{
  constructor(actions,d){
    this.actions=actions; this.d=d; this.alpha=0.65; this.models={};
    actions.forEach(a=>this.init(a));
  }
  init(a){ if(this.models[a]) return; this.models[a]={Ainv:eye(this.d), b:zeros(this.d), n:0, rSum:0}; }
  choose(x){
    let best=this.actions[0], bestScore=-1e9;
    for(const a of this.actions){
      this.init(a);
      const m=this.models[a];
      const theta=matVec(m.Ainv,m.b);
      const mean=dot(theta,x);
      const bonus=this.alpha*Math.sqrt(Math.max(1e-12, quad(x,m.Ainv)));
      const s=mean+bonus;
      if(s>bestScore){bestScore=s; best=a;}
    }
    return best;
  }
  update(a,x,r){
    this.init(a);
    const m=this.models[a];
    m.Ainv=sherman(m.Ainv,x);
    for(let i=0;i<this.d;i++) m.b[i]+=r*x[i];
    m.n++; m.rSum+=r;
  }
}

const LEVELS=["SOFT","NORMAL","ASSERTIVE"];
const TOKENS=["NUDGE_LEFT","NUDGE_RIGHT","NUDGE_ALT","NUDGE_BREATH"];
const RHOS=[-0.20,-0.10,0.00,+0.10,+0.20];
function buildActs(tokens,rhos){const a=[]; tokens.forEach(t=>rhos.forEach(r=>a.push(`${t}::${r.toFixed(2)}`))); return a;}
const LOW_ACTS=buildActs(TOKENS,RHOS);
const banditLevel=new LinUCB(LEVELS,8);
const banditLow=new LinUCB(LOW_ACTS,8);

function ctxVec(phiS,phiM,phiL){
  const cap=getCap();
  const bNorm=clamp(budgetUsed()/Math.max(1e-9,(CFG.BUDGET_WIN*cap*cap*0.25)),0,2);
  const duNorm=clamp(duUsed()/1.2,0,2);
  return [1,
    clamp(phiS.Ymean/255,0,1),
    clamp(phiS.snoreRatio,0,1),
    clamp(phiM.Ymean/255,0,1),
    clamp(phiM.snoreRatio,0,1),
    clamp(phiL.snoreRatio,0,1),
    clamp(bNorm/2,0,1),
    clamp(duNorm/2,0,1)
  ];
}
function allowed(level){
  if(level==="SOFT") return {capScale:0.75, tokens:TOKENS, rhos:[-0.20,-0.10,0.00,+0.10]};
  if(level==="NORMAL") return {capScale:1.00, tokens:TOKENS, rhos:[-0.20,-0.10,0.00,+0.10,+0.20]};
  return {capScale:1.05, tokens:TOKENS, rhos:[-0.10,0.00,+0.10,+0.20]};
}
function chooseMaskedLow(x,level){
  const allow=allowed(level);
  const allowedSet=new Set(buildActs(allow.tokens,allow.rhos));
  let best=null, bestScore=-1e9;
  for(const a of LOW_ACTS){
    if(!allowedSet.has(a)) continue;
    const m=banditLow.models[a];
    const theta=matVec(m.Ainv,m.b);
    const mean=dot(theta,x);
    const bonus=banditLow.alpha*Math.sqrt(Math.max(1e-12, quad(x,m.Ainv)));
    const s=mean+bonus;
    if(s>bestScore){bestScore=s; best=a;}
  }
  return best || "NUDGE_ALT::0.00";
}
function parseActionKey(a){const [tok,r]=a.split("::"); return {tok, rho:parseFloat(r)};}

/* ============ IF Probe / CIEU（保留） ============ */
let probe={enabled:false, perHour:0, hourStart:0, inProbe:false, tEnd:0, key:null, accE:0, accD:0, accT:0, abort:0};
const motifTable=new Map();
function resetProbeHour(){
  const w=wallNow();
  if(probe.hourStart===0) probe.hourStart=w;
  if(w-probe.hourStart>=3600*1000){ probe.hourStart=w; probe.perHour=0; }
}
function canProbe(){
  if(!probe.enabled) return false;
  if(sleepLatencySec==null) return false;
  if(!(phase==="STABLE" && stage==="CALM")) return false;
  resetProbeHour();
  if(probe.perHour>=CFG.PROBE_MAX_PER_H) return false;
  if(probe.inProbe) return false;
  return true;
}
function motifKeyFrom(feat, phiM){
  const srBin=Math.round(clamp(phiM.snoreRatio,0,1)*10)/10;
  return `sr${srBin}_st${stage}`;
}
function estimateCycleSec(feat){
  const p=clamp(feat.periodicity,0,1);
  return clamp(0.85-0.45*p,0.35,0.90);
}
function startProbe(key,cycleSec,t){
  probe.inProbe=true;
  probe.tEnd=t+cycleSec;
  probe.key=key;
  probe.accE=0; probe.accD=0; probe.accT=0;
  probe.perHour++;
}
function abortProbe(){ probe.inProbe=false; probe.abort++; }
function finishProbe(){ motifTable.set(probe.key, {eCycle:probe.accE, dCycle:probe.accD, tCycle:probe.accT}); probe.inProbe=false; }

let currentCIEU=null;
function startCIEU(t, x, phiS, phiM, phiL, action, yStart, yStarStart){
  currentCIEU = {
    type:"CIEU",
    id:`cieu_${Date.now()}_${Math.floor(Math.random()*1e6)}`,
    t0: t,
    t0Wall: Date.now(),
    x_t:{ctx:x, phiS0:phiS, phiM0:phiM, phiL0:phiL, phase0:phase, stage0:stage},
    u_t:{level:action.level, actionKey:action.actionKey, token:action.token, rho:action.rho},
    yStar_t:{startY:yStart, startYStar:yStarStart},
    y_out:{peakY:yStart, E_exceed:0, E_delta:0, uEnergy:0, uPeak:0, duration:0},
    if_t:{motifKnownSec:0},
    motion_t:{enabled:(motion.enabled&&motion.permitted), turnDetected:false},
    r_t:{rewardNorm:0, components:{}}
  };
}
function finishCIEU(t){
  if(!currentCIEU) return;
  currentCIEU.y_out.duration = t - currentCIEU.t0;
  const sqw=getSQW();
  const dur=Math.max(1e-6, currentCIEU.y_out.duration);
  const meanEdelta = currentCIEU.y_out.E_delta / dur;
  const benefit = clamp(1 - (meanEdelta / 2500), 0, 1);
  const uMean = currentCIEU.y_out.uEnergy / dur;
  const uPeakN = getCap()>0 ? clamp(currentCIEU.y_out.uPeak / getCap(), 0, 2) : 0;
  const duPenalty = clamp(duUsed()/0.8,0,2);
  const turnBonus = currentCIEU.motion_t.turnDetected ? 0.08 : 0.0;
  const cost = sqw*(0.42*uMean + 0.35*uPeakN + 0.23*duPenalty);
  const r = clamp((benefit + turnBonus) - cost, -1, 1);
  currentCIEU.r_t.rewardNorm = r;
  currentCIEU.r_t.components = {benefit, turnBonus, cost, uMean, uPeakN, duPenalty, meanEdelta};
  pushDB(currentCIEU);
  currentCIEU=null;
}

/* ============ 趋势演示器：Y / Y* / u ============ */
const cCtx=ui.cvs.getContext("2d");
let bY  = new Array(CFG.SCOPE_N).fill(0);
let bYs = new Array(CFG.SCOPE_N).fill(0);
let bU  = new Array(CFG.SCOPE_N).fill(0);

function resizeCanvas(){
  const dpr=Math.max(1, window.devicePixelRatio||1);
  const w=ui.cvs.clientWidth;
  const h=ui.cvs.clientHeight;
  ui.cvs.width=Math.floor(w*dpr);
  ui.cvs.height=Math.floor(h*dpr);
  cCtx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/**
 * 这里的 Y / Ys 是 0–255，u 是 0–1
 * 没有事件时传 0,0,0，三条线趴在底部
 */
function drawScope(Y, Ys, u, thr){
  const w=ui.cvs.clientWidth;
  const h=ui.cvs.clientHeight;
  cCtx.clearRect(0,0,w,h);

  bY.push(Y);  bY.shift();
  bYs.push(Ys); bYs.shift();
  bU.push(u);  bU.shift();

  // 阈值虚线，只做背景参考
  const yT=h-(thr/255)*h;
  cCtx.save();
  cCtx.strokeStyle="rgba(255,255,255,0.18)";
  cCtx.lineWidth=1;
  cCtx.setLineDash([6,6]);
  cCtx.beginPath(); cCtx.moveTo(0,yT); cCtx.lineTo(w,yT); cCtx.stroke();
  cCtx.restore();

  // 蓝线：Y 趋势
  cCtx.strokeStyle="#00f2ff";
  cCtx.lineWidth=1.5;
  cCtx.beginPath();
  for(let i=0;i<bY.length;i++){
    const xx=i/(bY.length-1)*w;
    const yy=h-(bY[i]/255)*h;
    if(i===0) cCtx.moveTo(xx,yy); else cCtx.lineTo(xx,yy);
  }
  cCtx.stroke();

  // 橙线：Y* 趋势
  cCtx.strokeStyle="#ff9f0a";
  cCtx.lineWidth=1.6;
  cCtx.beginPath();
  for(let i=0;i<bYs.length;i++){
    const xx=i/(bYs.length-1)*w;
    const yy=h-(bYs[i]/255)*h;
    if(i===0) cCtx.moveTo(xx,yy); else cCtx.lineTo(xx,yy);
  }
  cCtx.stroke();

  // 红线：u 趋势（0–1）
  cCtx.strokeStyle="#ff3b30";
  cCtx.lineWidth=1.2;
  cCtx.beginPath();
  for(let i=0;i<bU.length;i++){
    const xx=i/(bU.length-1)*w;
    const yy=h-(bU[i])*h;
    if(i===0) cCtx.moveTo(xx,yy); else cCtx.lineTo(xx,yy);
  }
  cCtx.stroke();
}

/* ============ Runtime loop ============ */
let running=false;
let lastTick=0, t=0, dt=1/CFG.LOGIC_HZ;
let ambient=0, ambientN=0, dynThr=null, state="IDLE";
let pidI=0;
let simulate=false;
let nudgeNext=0;
let action={level:"SOFT", actionKey:"NUDGE_ALT::0.00", token:"NUDGE_ALT", rho:0.0};

function newSession(t0){
  return {
    type:"SESSION",
    id:`sess_${Date.now()}`,
    t0, t0Wall:Date.now(),
    calibStart: nowMs(),
    ambientYmean:null,
    dynThr:null,
    sleepLatencySec:null,
    inEvent:false,
    eventT0:0,
    eventStartY:0,
    below:null,
    E_real:0,
    E_delta:0,
    uEnergy:0,
    uPeak:0,
    E_if:0,
    deltaE_if:0,
    motifCoverageSec:0,
    probeEnabled:false,
    probePerHour:0,
    probeAbort:0,
    motifs:0,
    motionEnabled:false,
    turns:0
  };
}
let session=newSession(nowMs()/1000);

function sleepBase(){
  if(phase==="ONSET") return 0.78;
  const elapsed=t-session.t0;
  if(elapsed>CFG.ONSET_BG_AFTER) return CFG.ONSET_BG_LEVEL;
  return 0.50;
}
function decideSleep(){
  const sel=ui.sleepSel.value;
  if(sel==="OFF") return "OFF";
  if(sel!=="AUTO") return sel;
  return "OCEAN_SOFT";
}

function loop(){
  if(!running) return;
  const tNow=nowMs()/1000;
  dt=(lastTick>0)?(tNow-lastTick):(1/CFG.LOGIC_HZ);
  lastTick=tNow;
  t=tNow;

  const feat=computeFeatures();
  let Y=computeY(feat);
  const thr=getTHR();

  pushBuf(bufS,CFG.PHI_S,{t,dt,Y});
  pushBuf(bufM,CFG.PHI_M,{t,dt,Y});
  pushBuf(bufL,CFG.PHI_L,{t,dt,Y});
  const phiS=phiFrom(bufS,thr);
  const phiM=phiFrom(bufM,thr);
  const phiL=phiFrom(bufL,thr);

  stage=estimateStage(phiM,Y);
  updateSleepLatency(phiM,t,dt);
  updatePhase(phiM,phiL);

  if(state==="CALIB"){
    ambientN++;
    ambient += (Y-ambient)/Math.max(1,ambientN);
    if(nowMs()-session.calibStart>CFG.CALIB_MS){
      dynThr=thr;            // 阈值直接由滑块决定
      session.dynThr=dynThr;
      session.ambientYmean=ambient;
      state="RUN";
    }
  }

  const sleepName=decideSleep();
  if(sleepName==="OFF"){ applySleep("OFF"); setSleepBus(0); }
  else { applySleep(sleepName); setSleepBus(sleepBase()); }

  const x = ctxVec(phiS,phiM,phiL);
  if(!action._optActive){
    action._optActive=true;
    action._optEnd=t+getOptSec();
    banditLevel.alpha=getAlpha();
    banditLow.alpha=getAlpha();
    action.level = banditLevel.choose(x);
    const a = chooseMaskedLow(x, action.level);
    action.actionKey = a;
    const p = parseActionKey(a);
    action.token = p.tok;
    action.rho = p.rho;
    action._x = x;
    action._stats = {sumT:0, E_delta_norm:0, uMean:0, uPeakN:0, strong:0, duNorm:0, turnBonus:0};
  }
  if(action._optActive && t>=action._optEnd){
    const stats=action._stats;
    const meanE = stats.sumT>0 ? (stats.E_delta_norm/stats.sumT) : 0;
    const benefit = clamp(1 - (meanE/0.04), 0, 1);
    const cost = getSQW()*(0.42*stats.uMean + 0.35*stats.uPeakN + 0.23*stats.duNorm + 0.12*clamp(stats.strong/2,0,2));
    const r = clamp((benefit + stats.turnBonus) - cost, -1, 1);
    banditLow.update(action.actionKey, action._x, r);
    banditLevel.update(action.level, action._x, r);
    action._optActive=false;
  }

  const useThr=thr;
  const detectThr=useThr;

  if(simulate){ Y=Math.max(Y, detectThr+50); }

  const wantEvent = (Y>detectThr) || simulate;

  if(!session.inEvent && wantEvent){
    session.inEvent=true;
    session.eventT0=t;
    session.eventStartY=Y;
    phase="EVENT";
    nudgeNext=ctx.currentTime;
    const yStar0 = computeYStar(0, Y, phiS,phiM,phiL).ys;
    startCIEU(t, x, phiS,phiM,phiL, action, Y, yStar0);
  }

  if(session.inEvent && !wantEvent){
    if(session.below==null) session.below=t;
    if(t-session.below>2){
      session.inEvent=false;
      session.below=null;
      finishCIEU(t);
    }
  } else {
    session.below=null;
  }

  let Ystar;
  if(session.inEvent){
    const yStarObj = computeYStar(t-session.eventT0, session.eventStartY, phiS,phiM,phiL);
    Ystar = yStarObj.ys;
  } else {
    Ystar = useThr;
  }

  const exceed=Math.max(0,Y-useThr);
  session.E_real += (exceed*exceed)*dt;
  const deltaPlus=Math.max(0,Y-Ystar);
  session.E_delta += (deltaPlus*deltaPlus)*dt;

  const key = motifKeyFrom(feat, phiM);
  if(motifTable.has(key) && Y>useThr){
    const rec = motifTable.get(key);
    const scale = (rec.tCycle>0) ? (dt/rec.tCycle) : 0;
    session.E_if += rec.eCycle*scale;
    session.motifCoverageSec += dt;
    if(currentCIEU) currentCIEU.if_t.motifKnownSec += dt;
  }
  session.deltaE_if = session.E_if - session.E_real;

  probe.enabled = ui.ifProbe.checked;
  session.probeEnabled = probe.enabled;
  if(canProbe() && !motifTable.has(key) && Y>useThr){
    startProbe(key, estimateCycleSec(feat), t);
  }

  let u=0;
  const mode=getMode(phase, stage);

  if(probe.inProbe){
    u=0; setNudgeBus(0);
    probe.accE += (exceed*exceed)*dt;
    probe.accD += exceed*dt;
    probe.accT += (Y>useThr)?dt:0;
    if(Y>useThr+CFG.PROBE_ABORT_MARGIN) abortProbe();
    else if(!(phase==="STABLE" && stage==="CALM")) abortProbe();
    else if(t>=probe.tEnd) finishProbe();

  } else if(mode==="monitor"){
    u=0; setNudgeBus(0);

  } else {
    const e=Math.max(0, clamp((Y-Ystar)/255, -1, 1));
    const kp=0.40, ki=0.04;
    pidI=clamp(pidI + e*dt, 0, 0.9);
    const uPID=clamp(kp*e + ki*pidI, 0, 1);
    const cap=getCap()*allowed(action.level).capScale;
    u=applySafety(uPID*(1+action.rho), cap, t, dt);
    setNudgeBus(Math.min(u,0.35));
    pushBudget(t,dt,u);
    session.uEnergy += (u*u)*dt;
    session.uPeak = Math.max(session.uPeak, u);

    if(session.inEvent && u>0.03){
      const gap=clamp(CFG.NUDGE_MAX_GAP - u*(CFG.NUDGE_MAX_GAP-CFG.NUDGE_MIN_GAP), CFG.NUDGE_MIN_GAP, CFG.NUDGE_MAX_GAP);
      if(ctx.currentTime >= nudgeNext){
        scheduleNudge(action.token, clamp(u,0,1));
        nudgeNext = ctx.currentTime + gap;
      }
    }

    if(action._optActive){
      const dNorm=Math.max(0,(Y-Ystar)/255);
      action._stats.sumT += dt;
      action._stats.E_delta_norm += (dNorm*dNorm)*dt;
      action._stats.uMean += (cap>0 ? (u/cap) : 0)*dt;
      action._stats.uPeakN = Math.max(action._stats.uPeakN, cap>0 ? (u/cap) : 0);
      action._stats.duNorm = clamp(duUsed()/0.8,0,2);
      if(u>0.75*cap) action._stats.strong += 1;
      if(motion.enabled && motion.permitted && motion.turnEvent){
        action._stats.turnBonus = 0.08;
      }
    }

    if(currentCIEU){
      currentCIEU.y_out.peakY = Math.max(currentCIEU.y_out.peakY, Y);
      currentCIEU.y_out.E_exceed += (exceed*exceed)*dt;
      currentCIEU.y_out.E_delta += (deltaPlus*deltaPlus)*dt;
      currentCIEU.y_out.uEnergy += (u*u)*dt;
      currentCIEU.y_out.uPeak = Math.max(currentCIEU.y_out.uPeak, u);
      if(motion.enabled && motion.permitted && motion.turnEvent){
        currentCIEU.motion_t.turnDetected = true;
        session.turns += 1;
        motion.turnEvent=false;
      }
    }
  }

  if(mode!=="monitor" && (session.inEvent || u>0.05)){
    setSleepBus(Math.min(sleepBase(),0.25));
  }

  // === Overlay ===
  ui.oPhase.textContent=phase;
  ui.oStage.textContent=stage;
  ui.oLevel.textContent=action.level;
  ui.oAction.textContent=action.actionKey;
  ui.oDE.textContent=session.deltaE_if.toFixed(1);
  ui.oTurns.textContent=String(session.turns||0);
  ui.oMotion.textContent=(motion.enabled && motion.permitted)?"ON":"OFF";
  session.probePerHour = probe.perHour;
  session.probeAbort   = probe.abort;
  session.motifs       = motifTable.size;

  // === 趋势演示器 gating ===
  // 没有事件，也没有接近阈值的 wantEvent -> 三条线都传 0（贴底）
  // 有事件/接近阈值 -> 传真实的 Y, Y*, u
  let trendY  = 0;
  let trendYs = 0;
  let trendU  = 0;
  if (session.inEvent || wantEvent) {
    trendY  = Y;
    trendYs = Ystar;
    trendU  = clamp(u,0,1);
  }
  drawScope(trendY, trendYs, trendU, useThr);

  setTimeout(loop, 1000/CFG.LOGIC_HZ);
}

/* ============ Buttons / Start / Stop ============ */
ui.showDebug.checked=false;
ui.debugPanel.classList.add("hidden");

ui.btnSelfTest.addEventListener("click", async ()=>{
  try{
    alert("SELF TEST start");
    const AC=window.AudioContext||window.webkitAudioContext;
    if(!AC) throw new Error("No AudioContext");
    const tctx=new AC();
    await tctx.resume();
    alert("AudioContext="+tctx.state);
    const stream=await navigator.mediaDevices.getUserMedia({audio:true});
    alert("Mic OK. tracks="+stream.getTracks().length);
    stream.getTracks().forEach(t=>t.stop());
    await tctx.close();
    log("SELF TEST PASS");
  }catch(e){
    alert("SELF TEST FAIL: "+(e?.name||"")+" "+(e?.message||e));
    log("SELF TEST FAIL: "+(e?.name||"")+" "+(e?.message||e));
  }
});

ui.btnMotionPerm.addEventListener("click", requestMotionPerm);
ui.useMotion.addEventListener("change", ()=>{
  motion.enabled = ui.useMotion.checked;
  if(!motion.enabled) setPill(ui.pillMotion,"warn","motion: off");
  else setPill(ui.pillMotion, motion.permitted?"ok":"warn", motion.permitted?"motion: on":"motion: need perm");
});

ui.btnSim.addEventListener("pointerdown",(e)=>{e.preventDefault(); simulate=true; ui.btnSim.classList.add("active");});
ui.btnSim.addEventListener("pointerup",(e)=>{e.preventDefault(); simulate=false; ui.btnSim.classList.remove("active");});
ui.btnSim.addEventListener("pointercancel",()=>{simulate=false; ui.btnSim.classList.remove("active");});
document.addEventListener("pointerup",()=>{simulate=false; ui.btnSim.classList.remove("active");});

ui.btnExportReport.addEventListener("click", ()=>{
  const payload={type:"REPORT", session, motifs:[...motifTable.entries()], savedAt:Date.now()};
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download=`SnoreField_Report_${Date.now()}.json`; a.click();
  URL.revokeObjectURL(url);
});
ui.btnExportLocal.addEventListener("click", ()=>{
  const blob=new Blob([JSON.stringify(DB,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download=`SnoreField_LOCAL_${Date.now()}.json`; a.click();
  URL.revokeObjectURL(url);
});
ui.btnSnapshot.addEventListener("click", ()=>{
  pushDB({type:"SNAPSHOT", session, motifs:[...motifTable.entries()], savedAt:Date.now()});
  alert("Snapshot saved");
});
ui.btnClearLocal.addEventListener("click", ()=>{
  DB=[]; saveJSON(STORE.DB,DB);
  alert("Local cleared");
});

async function startSystem(){
  if(running) return;
  try{
    ensureAudio();
    await ctx.resume();
    setPill(ui.pillAudio, ctx.state==="running"?"ok":"warn", "audio: "+ctx.state);
    await ensureMic();
    motion.enabled = ui.useMotion.checked;
    if(motion.enabled && motion.permitted) setPill(ui.pillMotion,"ok","motion: on");
    else if(motion.enabled) setPill(ui.pillMotion,"warn","motion: need perm");
    else setPill(ui.pillMotion,"warn","motion: off");
    applySleep("OCEAN_SOFT");
    masterOn(true);
    setSleepBus(0.78);
    setNudgeBus(0);

    running=true;
    phase="ONSET"; stage="CALM"; state="CALIB";
    lastTick=0; t=0; dt=1/CFG.LOGIC_HZ;
    ambient=0; ambientN=0; dynThr=null;
    pidI=0; lastU=0; strongTimes=[];
    bufS=[];bufM=[];bufL=[];budgetBuf=[];duBuf=[];
    sleepLatencySec=null; onsetStable=0;
    probe={enabled:false, perHour:0, hourStart:0, inProbe:false, tEnd:0, key:null, accE:0, accD:0, accT:0, abort:0};
    motifTable.clear();
    session=newSession(nowMs()/1000);
    action={level:"SOFT", actionKey:"NUDGE_ALT::0.00", token:"NUDGE_ALT", rho:0.0, _optActive:false};
    ui.btnActivate.textContent="STOP";
    loop();
  }catch(e){
    log("START FAIL: "+(e?.name||"")+" "+(e?.message||e));
    alert("START FAIL: "+(e?.message||e));
  }
}

function stopSystem(){
  if(!running) return;
  running=false;
  finishCIEU(t);
  pushDB({type:"SESSION_SUMMARY", ...session, motifs: motifTable.size, savedAt:Date.now()});
  try{ setNudgeBus(0); setSleepBus(0); masterOn(false); }catch(e){}
  ui.btnActivate.textContent="ACTIVATE";
  if(ui.autoBackup.checked){
    const payload={type:"REPORT", session, motifs:[...motifTable.entries()], savedAt:Date.now()};
    const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download=`SnoreField_Report_${Date.now()}.json`; a.click();
    URL.revokeObjectURL(url);
  }
}

ui.btnActivate.addEventListener("click", ()=> running ? stopSystem() : startSystem());

setPill(ui.pillAudio,"warn","audio: suspended");
setPill(ui.pillMic,"warn","mic: off");
setPill(ui.pillMotion,"warn","motion: off");
log("Loaded v8.0 full core (trend scope gated). Debug hidden by default.");
</script>
</body>
</html>
